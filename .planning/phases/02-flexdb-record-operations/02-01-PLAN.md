---
phase: 02-flexdb-record-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/plugins/workscript/schema/flexdb.schema.ts
  - apps/api/src/plugins/workscript/services/FlexRecordService.ts
  - apps/api/src/plugins/workscript/services/FlexQueryBuilder.ts
  - apps/api/src/plugins/workscript/services/index.ts
autonomous: true

must_haves:
  truths:
    - "Inserting a record returns it within 100ms"
    - "Queries on indexed fields return results within 100ms"
    - "Full-text search with common words returns relevant records"
    - "Updating a record with correct version succeeds"
    - "Updating a record with stale version returns conflict error"
    - "Soft-deleted records are excluded from queries by default"
  artifacts:
    - path: "apps/api/src/plugins/workscript/schema/flexdb.schema.ts"
      provides: "flex_records table definition with JSON data + indexed slots"
      contains: "flexRecords = mysqlTable"
    - path: "apps/api/src/plugins/workscript/services/FlexRecordService.ts"
      provides: "CRUD operations for FlexDB records"
      exports: ["FlexRecordService", "flexRecordService"]
    - path: "apps/api/src/plugins/workscript/services/FlexQueryBuilder.ts"
      provides: "Query DSL to Drizzle translation"
      exports: ["FlexQueryBuilder", "buildFilterConditions"]
  key_links:
    - from: "FlexRecordService"
      to: "flexRecords table"
      via: "Drizzle ORM insert/select/update/delete"
      pattern: "db\\.insert\\(flexRecords\\)|db\\.query\\.flexRecords"
    - from: "FlexRecordService"
      to: "FlexQueryBuilder"
      via: "buildFilterConditions call"
      pattern: "buildFilterConditions"
    - from: "FlexRecordService"
      to: "flexTables"
      via: "table schema lookup for validation"
      pattern: "db\\.query\\.flexTables"
---

<objective>
Create the FlexDB record storage infrastructure with flex_records table, FlexRecordService for CRUD operations, and FlexQueryBuilder for dynamic query translation.

Purpose: Enable record storage and retrieval for runtime-created FlexDB tables with indexed slots for query performance and full-text search support.

Output:
- flex_records Drizzle schema with JSON data column and indexed virtual columns
- FlexRecordService with insert, findOne, findMany, update, delete operations
- FlexQueryBuilder for translating query DSL to Drizzle/MySQL queries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-flexdb-record-operations/02-RESEARCH.md
@.planning/phases/01-flexdb-schema-foundation/01-01-SUMMARY.md
@.planning/phases/01-flexdb-schema-foundation/01-02-SUMMARY.md

# Existing code patterns
@apps/api/src/plugins/workscript/schema/flexdb.schema.ts
@apps/api/src/plugins/workscript/services/FlexDBService.ts
@apps/api/src/plugins/workscript/services/FlexSchemaValidator.ts
@apps/api/src/plugins/workscript/services/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flex_records table to Drizzle schema</name>
  <files>apps/api/src/plugins/workscript/schema/flexdb.schema.ts</files>
  <action>
Add the flex_records table to the existing flexdb.schema.ts file:

1. Add the flex_records table definition with:
   - id: VARCHAR(128) primary key with createId default
   - tableId: VARCHAR(128) not null (foreign key to flex_tables)
   - applicationId: VARCHAR(128) not null (for multi-tenancy)
   - data: JSON not null with $type<Record<string, unknown>>() for record data
   - idxStr1, idxStr2, idxStr3: VARCHAR(255) nullable - indexed string slots
   - idxNum1, idxNum2: DECIMAL(18,4) nullable - indexed numeric slots
   - idxDate1, idxDate2: DATE nullable - indexed date slots
   - searchText: TEXT nullable - for full-text search
   - version: INT not null default 1 - for optimistic locking
   - createdAt, updatedAt: TIMESTAMP with defaults
   - deletedAt: TIMESTAMP nullable for soft delete

2. Add indexes in the table's callback:
   - tableIdx on tableId
   - appIdx on applicationId
   - str1Idx, str2Idx, str3Idx on indexed string columns
   - num1Idx, num2Idx on indexed numeric columns
   - date1Idx, date2Idx on indexed date columns
   - Comment for FULLTEXT index (requires raw SQL migration)

3. Export types:
   - FlexRecord = typeof flexRecords.$inferSelect
   - NewFlexRecord = typeof flexRecords.$inferInsert

Follow the existing pattern from flexTables and flexTableVersions in the same file.
Use 'decimal' from drizzle-orm/mysql-core for the numeric index slots.

Note: FULLTEXT index on search_text requires separate raw SQL since Drizzle doesn't support it natively. Add a comment noting this.
  </action>
  <verify>
Run: `cd /Users/narcisbrindusescu/teste/workscript/apps/api && bun run db:push`
Verify flex_records table is created in MySQL with all columns and indexes.
Check: `bun run typecheck` passes in apps/api
  </verify>
  <done>
flex_records table exists in database with:
- JSON data column for record storage
- 7 indexed slots (3 string, 2 numeric, 2 date)
- searchText column for full-text search
- version column for optimistic locking
- Proper indexes on all indexed columns
- TypeScript types exported (FlexRecord, NewFlexRecord)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FlexQueryBuilder service</name>
  <files>apps/api/src/plugins/workscript/services/FlexQueryBuilder.ts</files>
  <action>
Create FlexQueryBuilder.ts that translates FlexDB query DSL into Drizzle ORM conditions.

1. Define query interfaces:
```typescript
// Simple filter: { field: value } or { field: { eq: value } }
interface FlexFilterCondition {
  field: string;
  eq?: unknown;
  ne?: unknown;
  gt?: number;
  gte?: number;
  lt?: number;
  lte?: number;
  in?: unknown[];
  contains?: string;
  startsWith?: string;
  endsWith?: string;
  between?: [unknown, unknown];
  isNull?: boolean;
  search?: string;  // Full-text search operator
}

// Advanced filter with logic operators (QRY-07)
interface FlexAdvancedFilter {
  AND?: (FlexFilterCondition | FlexAdvancedFilter)[];  // Nested AND
  OR?: (FlexFilterCondition | FlexAdvancedFilter)[];   // Nested OR
  NOT?: FlexFilterCondition | FlexAdvancedFilter;      // Nested NOT
}

// Query parameters
interface FlexQueryParams {
  tableId: string;
  filter?: Record<string, unknown> | FlexAdvancedFilter;
  orderBy?: { field: string; direction: 'asc' | 'desc' }[];
  limit?: number;
  offset?: number;
  includeDeleted?: boolean;
}
```

2. Implement helper functions:
   - getIndexSlotForField(field, indexedColumns): Returns slot name if field is indexed
   - getIndexedColumnRef(slotName): Returns the Drizzle column reference for a slot
   - slotNameToDbColumn(slotName): Maps 'str_1' to 'idxStr1' etc.

3. Implement buildSingleCondition(condition, schema, indexedColumns):
   - Check if field is indexed via indexedColumns mapping
   - If indexed: Use Drizzle operators (eq, gt, gte, lt, lte, like, between, inArray, isNull)
   - If not indexed: Use sql template with JSON_EXTRACT for JSON path queries
   - Handle all operators: eq, ne, gt, gte, lt, lte, in, contains, startsWith, endsWith, between, isNull

   **For 'search' operator (QRY-06 full-text search):**
   ```typescript
   // Full-text search MUST use MATCH AGAINST with BOOLEAN MODE
   if (search !== undefined) {
     return sql`MATCH(${flexRecords.searchText}) AGAINST(${search} IN BOOLEAN MODE)`;
   }
   ```
   This is the ONLY correct pattern for full-text search. Do NOT use LIKE.

4. Implement buildFilterConditions(filter, schema, indexedColumns):
   - Handle simple equality filter: { field: value } -> eq condition
   - **Handle nested logic operators (QRY-07):**
   ```typescript
   // Recursive handling for nested AND/OR/NOT
   function buildFilterConditions(
     filter: Record<string, unknown> | FlexAdvancedFilter,
     schema: FlexTableSchema,
     indexedColumns: Record<string, string>
   ): SQL | undefined {
     // Simple equality filter
     if (!('AND' in filter) && !('OR' in filter) && !('NOT' in filter)) {
       const conditions = Object.entries(filter).map(([field, value]) =>
         buildSingleCondition({ field, eq: value }, schema, indexedColumns)
       );
       return conditions.length > 0 ? and(...conditions) : undefined;
     }

     // Advanced filter with RECURSIVE logic operators
     const advanced = filter as FlexAdvancedFilter;

     if (advanced.AND) {
       const andConditions = advanced.AND.map(c => {
         // Recursively handle nested filters
         if ('AND' in c || 'OR' in c || 'NOT' in c) {
           return buildFilterConditions(c as FlexAdvancedFilter, schema, indexedColumns);
         }
         return buildSingleCondition(c as FlexFilterCondition, schema, indexedColumns);
       }).filter(Boolean) as SQL[];
       return and(...andConditions);
     }

     if (advanced.OR) {
       const orConditions = advanced.OR.map(c => {
         if ('AND' in c || 'OR' in c || 'NOT' in c) {
           return buildFilterConditions(c as FlexAdvancedFilter, schema, indexedColumns);
         }
         return buildSingleCondition(c as FlexFilterCondition, schema, indexedColumns);
       }).filter(Boolean) as SQL[];
       return or(...orConditions);
     }

     if (advanced.NOT) {
       const notTarget = advanced.NOT;
       if ('AND' in notTarget || 'OR' in notTarget || 'NOT' in notTarget) {
         const nested = buildFilterConditions(notTarget as FlexAdvancedFilter, schema, indexedColumns);
         return nested ? not(nested) : undefined;
       }
       const notCondition = buildSingleCondition(notTarget as FlexFilterCondition, schema, indexedColumns);
       return notCondition ? not(notCondition) : undefined;
     }

     return undefined;
   }
   ```

5. Export:
   - FlexQueryBuilder class with these methods
   - Pure functions for use without class
   - All interfaces (FlexFilterCondition, FlexAdvancedFilter, FlexQueryParams)

Key patterns from research:
- Use sql template literal from drizzle-orm for JSON_EXTRACT
- Use JSON_UNQUOTE for string comparisons in JSON
- Use CAST for numeric comparisons in JSON
- Combine conditions with and() / or() / not() from drizzle-orm
  </action>
  <verify>
1. TypeScript compilation:
   `cd /Users/narcisbrindusescu/teste/workscript/apps/api && bun run typecheck`

2. Create a test file to verify query building logic:
   Create `apps/api/src/plugins/workscript/services/FlexQueryBuilder.test.ts` with:
   ```typescript
   import { describe, it, expect } from 'vitest';
   import { buildFilterConditions, buildSingleCondition } from './FlexQueryBuilder';

   describe('FlexQueryBuilder', () => {
     const mockSchema = { columns: [{ name: 'status', dataType: 'string' }] };
     const indexedColumns = { str_1: 'status' };

     it('builds eq condition for indexed field', () => {
       const result = buildSingleCondition(
         { field: 'status', eq: 'active' },
         mockSchema,
         indexedColumns
       );
       expect(result).toBeDefined();
       // SQL should reference idxStr1, not JSON_EXTRACT
     });

     it('builds nested AND/OR conditions', () => {
       const filter = {
         AND: [
           { field: 'status', eq: 'active' },
           { OR: [
             { field: 'priority', gt: 5 },
             { field: 'urgent', eq: true }
           ]}
         ]
       };
       const result = buildFilterConditions(filter, mockSchema, {});
       expect(result).toBeDefined();
     });

     it('builds MATCH AGAINST for search operator', () => {
       const result = buildSingleCondition(
         { field: 'any', search: 'test query' },
         mockSchema,
         {}
       );
       // Verify result contains MATCH and AGAINST
       expect(result?.sql || result?.toString()).toMatch(/MATCH.*AGAINST/i);
     });
   });
   ```

3. Run test:
   `cd /Users/narcisbrindusescu/teste/workscript && bun test apps/api/src/plugins/workscript/services/FlexQueryBuilder.test.ts`
  </verify>
  <done>
FlexQueryBuilder.ts exists with:
- Query DSL interfaces (FlexFilterCondition, FlexAdvancedFilter, FlexQueryParams)
- buildFilterConditions function translating filters to Drizzle SQL
- Support for indexed column queries (fast path via idx_* columns)
- Support for non-indexed JSON queries (JSON_EXTRACT path)
- Support for all required operators: eq, ne, gt, gte, lt, lte, in, contains, startsWith, endsWith, between, isNull, search
- MATCH AGAINST pattern for full-text search (QRY-06)
- Recursive nested AND/OR/NOT logic operators (QRY-07)
- Tests verifying query building logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Create FlexRecordService with CRUD operations</name>
  <files>
    apps/api/src/plugins/workscript/services/FlexRecordService.ts
    apps/api/src/plugins/workscript/services/index.ts
  </files>
  <action>
Create FlexRecordService.ts following the established FlexDBService pattern:

Note: This task creates a substantial service (~500 lines) with 5 methods + helpers. This complexity is appropriate because:
- All methods are cohesive (CRUD for same entity)
- Splitting would create artificial boundaries
- Helper functions (extractIndexedValues, buildSearchText) are tightly coupled to CRUD operations

1. Define result types (reuse ServiceResult pattern from FlexDBService):
```typescript
export type FlexRecordErrorCode =
  | 'VALIDATION_ERROR'
  | 'NOT_FOUND'
  | 'REFERENCE_ERROR'
  | 'CONFLICT'
  | 'INTERNAL';
```

2. Implement helper functions:
   - extractIndexedValues(data, tableSchema, indexedColumns): Extract values to idx_* columns
     - Map slot names: str_1 -> idxStr1, num_1 -> idxNum1, date_1 -> idxDate1
     - Coerce values to match column types (string, decimal, date)
   - buildSearchText(data, tableSchema): Concatenate string/text fields for full-text
     - Filter columns where dataType is 'string' or 'text' and system is not true
     - Join values with spaces
     - Truncate at 60KB to stay under TEXT limit

3. Implement FlexRecordService class:

   a) insertRecord(tableId, data, userId?):
      - Get table schema from flexTables
      - Validate data against column definitions (required fields, types)
      - Extract indexed values
      - Build search text
      - Generate ID with createId()
      - Add system fields to data (id, created_at, updated_at, deleted_at: null)
      - Insert into flexRecords
      - Return created record

   b) findOne(recordId):
      - Query by ID with isNull(deletedAt)
      - Return record or NOT_FOUND error

   c) findMany(params: FlexQueryParams):
      - Get table schema for indexedColumns
      - Build base conditions (tableId, isNull(deletedAt) unless includeDeleted)
      - Use FlexQueryBuilder.buildFilterConditions for filter
      - Apply orderBy (use indexed columns when available, JSON_EXTRACT otherwise)
      - Apply limit (max 100) and offset
      - Return array of records

   d) updateRecord(recordId, updates, expectedVersion):
      - Implement optimistic locking: UPDATE WHERE id = ? AND version = expectedVersion
      - Increment version
      - Re-extract indexed values and search text
      - If 0 affected rows: fetch record to distinguish NOT_FOUND vs CONFLICT
      - Return updated record

   e) deleteRecord(recordId, hardDelete = false):
      - If soft delete: SET deletedAt = now() WHERE id = ? AND deletedAt IS NULL
      - If hard delete: DELETE WHERE id = ?
      - Return success or NOT_FOUND

4. Update services/index.ts:
   - Export FlexRecordService, flexRecordService
   - Export FlexQueryBuilder and related types

Follow established patterns:
- Use db from '../../../db'
- Use createId from @paralleldrive/cuid2
- Use eq, and, isNull, sql from drizzle-orm
- Return ServiceResult<T> discriminated union
  </action>
  <verify>
Run: `cd /Users/narcisbrindusescu/teste/workscript/apps/api && bun run typecheck`
TypeScript should compile without errors.

Manual verification (optional):
Create a simple test script or use the workflow API to:
1. Create a table via FlexDBService
2. Insert a record via FlexRecordService
3. Query the record
4. Update the record
5. Delete the record
  </verify>
  <done>
FlexRecordService.ts exists with:
- insertRecord: Creates records with validated data, indexed values, search text
- findOne: Retrieves single record by ID
- findMany: Queries records with filters, pagination, ordering
- updateRecord: Updates with optimistic locking (version check)
- deleteRecord: Soft delete (default) or hard delete
- Proper error handling with ServiceResult pattern
- Index extraction populates idx_str_1-3, idx_num_1-2, idx_date_1-2
- Search text populated from string/text columns
- Exported from services/index.ts
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database verification:
   ```bash
   cd apps/api && bun run db:push
   ```
   flex_records table should exist with all columns

2. Type checking:
   ```bash
   cd apps/api && bun run typecheck
   ```
   No TypeScript errors

3. Query builder tests:
   ```bash
   bun test apps/api/src/plugins/workscript/services/FlexQueryBuilder.test.ts
   ```
   All tests pass

4. Build verification:
   ```bash
   bun run build
   ```
   Full monorepo build succeeds
</verification>

<success_criteria>
- [ ] flex_records table exists in MySQL with JSON data + 7 indexed slots + searchText
- [ ] FlexQueryBuilder can translate all required filter operations to Drizzle SQL
- [ ] FlexQueryBuilder supports MATCH AGAINST for full-text search (QRY-06)
- [ ] FlexQueryBuilder supports nested AND/OR/NOT logic (QRY-07)
- [ ] FlexRecordService provides complete CRUD with index extraction and search text
- [ ] Optimistic locking works (version conflict detection)
- [ ] All services exported from services/index.ts
- [ ] TypeScript compiles without errors
- [ ] Query builder tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-flexdb-record-operations/02-01-SUMMARY.md`
</output>
