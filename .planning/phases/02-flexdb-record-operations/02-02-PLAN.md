---
phase: 02-flexdb-record-operations
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/nodes/src/flexdb/FlexRecordNode.ts
  - packages/nodes/src/flexdb/FlexTableNode.ts
  - packages/nodes/src/index.ts
  - apps/api/src/plugins/workscript/services/FlexRecordService.ts
  - apps/api/src/plugins/workscript/services/WorkflowService.ts
autonomous: true

must_haves:
  truths:
    - "User can insert records via flex-record workflow node"
    - "User can find single record by ID via flex-record node"
    - "User can query records with filters via flex-record node"
    - "User can update records via flex-record node (with conflict detection)"
    - "User can delete records via flex-record node (soft or hard)"
    - "System validates reference columns exist before insert"
    - "User can include related records in query results"
    - "System enforces onDelete behavior (cascade, set-null, restrict)"
  artifacts:
    - path: "packages/nodes/src/flexdb/FlexRecordNode.ts"
      provides: "Workflow node for record CRUD operations"
      exports: ["FlexRecordNode"]
      min_lines: 300
    - path: "packages/nodes/src/index.ts"
      provides: "Node registration"
      contains: "FlexRecordNode"
    - path: "apps/api/src/plugins/workscript/services/WorkflowService.ts"
      provides: "Service injection via initialState._services"
      contains: "_services"
  key_links:
    - from: "FlexRecordNode"
      to: "context.state._services.flexRecord"
      via: "service access from state (injected by WorkflowService)"
      pattern: "context\\.state\\._services\\.flexRecord"
    - from: "WorkflowService"
      to: "initialState._services"
      via: "service injection into workflow state"
      pattern: "_services.*flexDB.*flexRecord"
    - from: "FlexRecordNode"
      to: "context.state"
      via: "state variable updates"
      pattern: "context\\.state\\.(flexRecord|flexRecords|flexRecordId)"
    - from: "FlexRecordService"
      to: "reference validation"
      via: "validateReferences function"
      pattern: "validateReferences"
---

<objective>
Create the FlexRecordNode workflow node for record CRUD operations, fix service injection mechanism, and add relationship validation with include support to FlexRecordService.

Purpose: Enable workflows to perform complete record operations (insert, find, update, delete) with relationship handling. Also fixes the Phase 1 service injection gap where FlexTableNode expected `context.services.flexDB` but WorkflowService never actually injected it.

Output:
- FlexRecordNode workflow node registered in @workscript/nodes
- Service injection fixed in WorkflowService (uses initialState._services pattern)
- FlexTableNode updated to use the correct service access pattern
- Relationship validation before insert (reference columns)
- Include related records in query results
- onDelete behavior enforcement (cascade, set-null, restrict)

**Note on REL-02 (many-to-many relationships):** This phase implements one-to-many relationships via reference columns. Many-to-many relationships require junction tables, which users can create as standard FlexDB tables with two reference columns. This is an intentional simplification - the FlexDB system provides primitives (tables + references), and users compose them for complex relationships. Supporting native many-to-many would add significant complexity with minimal benefit since junction tables work equivalently.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-flexdb-record-operations/02-RESEARCH.md
@.planning/phases/01-flexdb-schema-foundation/01-03-SUMMARY.md

# Pattern reference (IMPORTANT: has the broken pattern that needs fixing)
@packages/nodes/src/flexdb/FlexTableNode.ts
@packages/nodes/src/index.ts

# Services from Plan 01 (will exist after Plan 01 executes)
@apps/api/src/plugins/workscript/services/FlexRecordService.ts
@apps/api/src/plugins/workscript/services/FlexQueryBuilder.ts
@apps/api/src/plugins/workscript/services/WorkflowService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix service injection and create FlexRecordNode with correct pattern</name>
  <files>
    apps/api/src/plugins/workscript/services/WorkflowService.ts
    packages/nodes/src/flexdb/FlexTableNode.ts
    packages/nodes/src/flexdb/FlexRecordNode.ts
    packages/nodes/src/index.ts
  </files>
  <action>
**CRITICAL CONTEXT: Service Injection Gap from Phase 1**

The FlexTableNode was created in Phase 1 expecting `context.services.flexDB`, but WorkflowService.executeWorkflow() NEVER actually injects services. The ExecutionEngine.execute() only accepts a ParsedWorkflow and builds ExecutionContext from workflow.initialState.

Looking at the code:
- ExecutionEngine.execute(workflow) creates context with state from workflow.initialState
- WorkflowService injects JWT_token into parsedWorkflow.initialState
- FlexTableNode tries to access context.services.flexDB via type cast - but this property is NEVER set

**FIX: Use initialState._services pattern** since initialState flows into context.state.

**Part A: Fix WorkflowService.ts service injection**

1. Add imports at top of WorkflowService.ts:
   ```typescript
   import { flexDBService } from './services/FlexDBService';
   import { flexRecordService } from './services/FlexRecordService';
   ```

2. Modify executeWorkflow method to inject services via _services property:
   ```typescript
   public async executeWorkflow(workflowDefinition: WorkflowDefinition, initialState?: any) {
     // Parse and validate workflow
     const parsedWorkflow = this.parser.parse(workflowDefinition);

     // Generate service token for internal API calls
     const jwtManager = JWTManager.getInstance();
     const serviceToken = await jwtManager.generateServiceToken();

     // Build initial state with service token AND services
     // Services are injected via _services so nodes can access them from context.state
     const stateToUse = {
       ...(initialState || {}),
       JWT_token: serviceToken,
       _services: {
         flexDB: flexDBService,
         flexRecord: flexRecordService,
       }
     };
     console.log('ðŸ”‘ Injected service token and FlexDB services for workflow execution');

     // Inject initial state into parsed workflow
     (parsedWorkflow as any).initialState = stateToUse;

     // Execute workflow
     return await this.executionEngine.execute(parsedWorkflow);
   }
   ```

**Part B: Fix FlexTableNode.ts to use context.state._services**

Update the service access pattern in FlexTableNode.execute():

FROM (broken):
```typescript
const flexDBService = (
  context as ExecutionContext & {
    services?: { flexDB?: FlexDBServiceInterface };
  }
).services?.flexDB;
```

TO (correct):
```typescript
// Services are injected via initialState._services by WorkflowService
// They flow into context.state during workflow execution
const flexDBService = (context.state._services as { flexDB?: FlexDBServiceInterface })?.flexDB;
```

Note: Update the JSDoc header at the top of FlexTableNode.ts to document the correct pattern:
```typescript
/**
 * ## Service Injection Pattern
 *
 * FlexTableNode expects the FlexDBService to be injected via `context.state._services.flexDB`.
 * The API's WorkflowService injects services into initialState._services before running workflows.
 * This pattern works because initialState flows into context.state during execution.
 */
```

**Part C: Create FlexRecordNode.ts using the CORRECT pattern:**

1. Add JSDoc header documenting:
   - Service injection pattern (context.state._services.flexRecord)
   - Operations: insert, findOne, findMany, update, delete
   - Edge routing table
   - State variables set

2. Define interfaces (matching FlexRecordService):
```typescript
interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  code?: string;
}

interface FlexRecord {
  id: string;
  tableId: string;
  applicationId: string;
  data: Record<string, unknown>;
  version: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

interface FlexRecordServiceInterface {
  insertRecord(tableId: string, data: Record<string, unknown>, userId?: string): Promise<ServiceResult<FlexRecord>>;
  findOne(recordId: string): Promise<ServiceResult<FlexRecord>>;
  findMany(params: FlexQueryParams): Promise<FlexRecord[]>;
  updateRecord(recordId: string, updates: Record<string, unknown>, expectedVersion: number): Promise<ServiceResult<FlexRecord>>;
  deleteRecord(recordId: string, hardDelete?: boolean): Promise<ServiceResult<{ deleted: true }>>;
}
```

3. Create FlexRecordNode class extending WorkflowNode:

   metadata = {
     id: 'flex-record',
     name: 'FlexDB Record Operations',
     version: '1.0.0',
     description: 'Create, read, update, and delete FlexDB records with query support',
     inputs: ['operation', 'tableId', 'tableName', 'recordId', 'data', 'filter', 'orderBy', 'limit', 'offset', 'include', 'version', 'hardDelete'],
     outputs: ['record', 'records', 'count', 'deleted', 'version'],
     edgeDescriptions: {
       success: 'Operation completed successfully',
       found: 'Record(s) found',
       not_found: 'Record not found',
       empty: 'Query returned no results',
       conflict: 'Version conflict during update',
       error: 'Operation failed - check error message',
     },
     ai_hints: {
       purpose: 'Perform CRUD operations on FlexDB records with filtering and relationships',
       when_to_use: 'When you need to insert, find, update, or delete records in a FlexDB table',
       expected_edges: ['success', 'found', 'not_found', 'empty', 'conflict', 'error'],
       example_usage: '{"flex-record": {"operation": "insert", "tableId": "$.flexTableId", "data": {"name": "John"}, "success?": {...}}}',
       example_config: '{"operation": "insert|findOne|findMany|update|delete", "tableId": "string", "data?": "object", "filter?": "object"}',
       get_from_state: ['applicationId', 'flexTableId'],
       post_to_state: ['flexRecord', 'flexRecords', 'flexRecordId', 'flexRecordCount'],
     },
   };

4. Implement execute(context, config):
   ```typescript
   async execute(context: ExecutionContext, config?: Record<string, unknown>): Promise<EdgeMap> {
     const { operation, /* ...other params */ } = config || {};

     // Get service from context.state._services (injected by WorkflowService)
     const flexRecordService = (context.state._services as { flexRecord?: FlexRecordServiceInterface })?.flexRecord;

     if (!flexRecordService) {
       return {
         error: () => ({
           error: 'FlexRecordService not available. Ensure workflow is executed via WorkflowService.',
           code: 'SERVICE_UNAVAILABLE',
         }),
       };
     }

     // ... rest of execute logic
   }
   ```

5. Implement handler methods (following FlexTableNode pattern):

   a) handleInsert(context, service, tableId, data):
      - Validate tableId and data are provided
      - Call service.insertRecord(tableId, data, context.state.userId)
      - Set context.state.flexRecord, flexRecordId
      - Return success edge with record data
      - Handle errors: VALIDATION_ERROR, REFERENCE_ERROR -> error edge

   b) handleFindOne(context, service, recordId):
      - Validate recordId is provided
      - Call service.findOne(recordId)
      - If not found: set error state, return not_found edge
      - Set context.state.flexRecord, flexRecordId
      - Return found edge

   c) handleFindMany(context, service, tableId, filter, orderBy, limit, offset, include):
      - Build FlexQueryParams from config
      - Call service.findMany(params)
      - If empty: set context.state.flexRecords = [], return empty edge
      - Set context.state.flexRecords, flexRecordCount
      - Return success edge with records array

   d) handleUpdate(context, service, recordId, data, expectedVersion):
      - Validate recordId and data
      - Get version from config or context.state.flexRecord?.version
      - Call service.updateRecord(recordId, data, version)
      - If CONFLICT: return conflict edge
      - If NOT_FOUND: return not_found edge
      - Set context.state.flexRecord, flexRecordId
      - Return success edge

   e) handleDelete(context, service, recordId, hardDelete):
      - Validate recordId
      - Call service.deleteRecord(recordId, hardDelete)
      - If NOT_FOUND: return not_found edge
      - Set context.state.deleted = true
      - Return success edge

6. Export default FlexRecordNode

7. Update packages/nodes/src/index.ts:
   - Import FlexRecordNode from './flexdb/FlexRecordNode.js'
   - Add to ALL_NODES array
   - Add to named exports
  </action>
  <verify>
Run: `cd /Users/narcisbrindusescu/teste/workscript && bun run build:nodes`
Verify FlexRecordNode is built without errors.

Run: `bun run typecheck`
Verify no TypeScript errors across monorepo.

Verify service injection pattern:
```bash
# Check WorkflowService injects _services
grep -n "_services" apps/api/src/plugins/workscript/services/WorkflowService.ts

# Check FlexTableNode uses context.state._services
grep -n "state._services" packages/nodes/src/flexdb/FlexTableNode.ts

# Check FlexRecordNode uses context.state._services
grep -n "state._services" packages/nodes/src/flexdb/FlexRecordNode.ts
```
  </verify>
  <done>
WorkflowService.ts updated with:
- flexDBService and flexRecordService imports
- _services object injected into initialState (so it flows to context.state)
- Pattern: initialState._services = { flexDB, flexRecord }

FlexTableNode.ts fixed to use:
- context.state._services.flexDB (instead of broken context.services.flexDB)
- Updated JSDoc documenting correct service injection pattern

FlexRecordNode.ts exists with:
- Complete metadata with ai_hints for workflow authoring
- All 5 operations: insert, findOne, findMany, update, delete
- Edge routing: success, found, not_found, empty, conflict, error
- State variables: flexRecord, flexRecords, flexRecordId, flexRecordCount
- Service access via context.state._services.flexRecord (correct pattern)
- Registered in ALL_NODES in packages/nodes/src/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add relationship validation and include support</name>
  <files>apps/api/src/plugins/workscript/services/FlexRecordService.ts</files>
  <action>
Enhance FlexRecordService with relationship handling:

1. Add validateReferences function:
```typescript
async function validateReferences(
  data: Record<string, unknown>,
  tableSchema: FlexTableSchema,
  applicationId: string
): Promise<{ valid: boolean; errors: string[] }> {
  const errors: string[] = [];

  // Find columns with dataType: 'reference' and validation.targetTable
  const referenceColumns = tableSchema.columns.filter(
    col => col.dataType === 'reference' && col.validation?.targetTable
  );

  for (const col of referenceColumns) {
    const refValue = data[col.name];

    // Skip if not required and no value provided
    if (!refValue && !col.required) continue;

    // If required but no value, that's caught by normal validation
    if (!refValue) continue;

    // Get target table
    const targetTable = await db.query.flexTables.findFirst({
      where: and(
        eq(flexTables.applicationId, applicationId),
        eq(flexTables.name, col.validation!.targetTable!),
        eq(flexTables.isActive, true)
      ),
    });

    if (!targetTable) {
      errors.push(`Reference column '${col.name}' targets non-existent table '${col.validation!.targetTable}'`);
      continue;
    }

    // Check referenced record exists and is not deleted
    const referencedRecord = await db.query.flexRecords.findFirst({
      where: and(
        eq(flexRecords.id, String(refValue)),
        eq(flexRecords.tableId, targetTable.id),
        isNull(flexRecords.deletedAt)
      ),
    });

    if (!referencedRecord) {
      errors.push(`Referenced record '${refValue}' not found for column '${col.name}'`);
    }
  }

  return { valid: errors.length === 0, errors };
}
```

2. Update insertRecord to call validateReferences:
   - After basic validation, before insert
   - If invalid: return { success: false, error: errors.join(', '), code: 'REFERENCE_ERROR' }

3. Add includeRelated function for findMany:
```typescript
async function includeRelated(
  records: FlexRecord[],
  tableSchema: FlexTableSchema,
  include: { relation: string }[],
  applicationId: string
): Promise<FlexRecord[]> {
  if (!include || include.length === 0) return records;

  // Find reference columns matching include relations
  const referenceColumns = tableSchema.columns.filter(
    col => col.dataType === 'reference' &&
           col.validation?.targetTable &&
           include.some(i => i.relation === col.name)
  );

  if (referenceColumns.length === 0) return records;

  // For each record, fetch related records
  for (const record of records) {
    const recordData = record.data as Record<string, unknown>;

    for (const col of referenceColumns) {
      const refId = recordData[col.name];
      if (!refId) continue;

      const related = await db.query.flexRecords.findFirst({
        where: and(
          eq(flexRecords.id, String(refId)),
          isNull(flexRecords.deletedAt)
        ),
      });

      if (related) {
        // Add to record data with _related prefix
        recordData[`_${col.name}`] = related.data;
      }
    }
  }

  return records;
}
```

4. Update findMany to support include parameter:
   - Add include to FlexQueryParams interface
   - After fetching records, call includeRelated if include provided
   - Return enriched records

5. Add handleCascadeDelete for onDelete behavior:
```typescript
async function handleCascadeDelete(
  recordId: string,
  tableId: string,
  applicationId: string
): Promise<void> {
  // Find all tables with reference columns pointing to this table
  const allTables = await db.query.flexTables.findMany({
    where: and(
      eq(flexTables.applicationId, applicationId),
      eq(flexTables.isActive, true)
    ),
  });

  for (const table of allTables) {
    const refColumns = table.schema.columns.filter(
      col => col.dataType === 'reference' &&
             col.validation?.targetTable
    );

    for (const col of refColumns) {
      // Get target table to check if it matches
      const targetTable = await db.query.flexTables.findFirst({
        where: and(
          eq(flexTables.applicationId, applicationId),
          eq(flexTables.name, col.validation!.targetTable!),
          eq(flexTables.isActive, true)
        ),
      });

      if (targetTable?.id !== tableId) continue;

      const onDelete = col.validation?.onDelete || 'restrict';

      // Find records referencing the deleted record
      const referencingRecords = await db.query.flexRecords.findMany({
        where: and(
          eq(flexRecords.tableId, table.id),
          isNull(flexRecords.deletedAt)
        ),
      });

      for (const ref of referencingRecords) {
        const refData = ref.data as Record<string, unknown>;
        if (refData[col.name] !== recordId) continue;

        switch (onDelete) {
          case 'cascade':
            // Soft delete the referencing record
            await db.update(flexRecords)
              .set({ deletedAt: new Date() })
              .where(eq(flexRecords.id, ref.id));
            break;
          case 'set-null':
            // Set the reference to null
            refData[col.name] = null;
            await db.update(flexRecords)
              .set({ data: refData })
              .where(eq(flexRecords.id, ref.id));
            break;
          case 'restrict':
            // This should have been caught before delete
            // If we get here, just log warning
            break;
        }
      }
    }
  }
}
```

6. Update deleteRecord:
   - Before delete, check for restrict references
   - If any restrict references exist: return error with code 'REFERENCE_ERROR'
   - After delete: call handleCascadeDelete for cascade/set-null handling
  </action>
  <verify>
Run: `cd /Users/narcisbrindusescu/teste/workscript/apps/api && bun run typecheck`
TypeScript should compile without errors.

Run: `bun run build`
Full monorepo build should succeed.
  </verify>
  <done>
FlexRecordService enhanced with:
- validateReferences: Validates reference columns exist before insert
- includeRelated: Fetches related records for include parameter
- handleCascadeDelete: Enforces onDelete behavior (cascade, set-null, restrict)
- insertRecord calls validateReferences before insert
- findMany supports include parameter for related records
- deleteRecord checks restrict references and handles cascade/set-null
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   bun run build
   ```
   Full monorepo build succeeds

2. Type checking:
   ```bash
   bun run typecheck
   ```
   No TypeScript errors

3. Node registration verification:
   ```bash
   grep -n "FlexRecordNode" packages/nodes/src/index.ts
   ```
   Should show import and ALL_NODES inclusion

4. Service injection verification:
   ```bash
   grep -n "_services" apps/api/src/plugins/workscript/services/WorkflowService.ts
   grep -n "state._services" packages/nodes/src/flexdb/FlexTableNode.ts
   grep -n "state._services" packages/nodes/src/flexdb/FlexRecordNode.ts
   ```
   All three files should show the correct pattern

5. Workflow integration test (optional):
   Create a test workflow that:
   - Creates a table with flex-table node
   - Inserts a record with flex-record node
   - Queries the record
   - Updates the record
   - Deletes the record
</verification>

<success_criteria>
- [ ] WorkflowService injects services via initialState._services pattern
- [ ] FlexTableNode fixed to access context.state._services.flexDB
- [ ] FlexRecordNode registered in @workscript/nodes with all 5 operations
- [ ] FlexRecordNode accesses service via context.state._services.flexRecord
- [ ] Reference validation prevents invalid references on insert
- [ ] Include parameter fetches related records in findMany
- [ ] onDelete behavior enforced (cascade, set-null, restrict)
- [ ] Full monorepo build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-flexdb-record-operations/02-02-SUMMARY.md`
</output>
