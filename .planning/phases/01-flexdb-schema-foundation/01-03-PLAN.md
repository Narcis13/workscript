---
phase: 01-flexdb-schema-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/api/src/plugins/workscript/services/FlexVersionService.ts
  - apps/api/src/plugins/workscript/services/index.ts
  - packages/nodes/src/flexdb/FlexTableNode.ts
  - packages/nodes/src/index.ts
autonomous: true

must_haves:
  truths:
    - "System creates version entry when schema is modified"
    - "Version history includes previous_schema, new_schema, and changes array"
    - "Changes include type (add_column, remove_column, modify_column)"
    - "User can query version history chronologically"
    - "flex-table workflow node can create tables"
  artifacts:
    - path: "apps/api/src/plugins/workscript/services/FlexVersionService.ts"
      provides: "Schema versioning and change detection"
      exports: ["FlexVersionService", "computeSchemaChanges"]
      min_lines: 80
    - path: "packages/nodes/src/flexdb/FlexTableNode.ts"
      provides: "Workflow node for FlexDB table operations"
      exports: ["FlexTableNode"]
      min_lines: 100
  key_links:
    - from: "apps/api/src/plugins/workscript/services/FlexVersionService.ts"
      to: "apps/api/src/plugins/workscript/schema/flexdb.schema.ts"
      via: "insert version records"
      pattern: "flexTableVersions"
    - from: "packages/nodes/src/flexdb/FlexTableNode.ts"
      to: "@workscript/engine"
      via: "extends WorkflowNode"
      pattern: "extends WorkflowNode"
---

<objective>
Create schema version tracking service and the flex-table workflow node.

Purpose: Complete Phase 1 by implementing version history (VER-01 to VER-04) and the workflow node interface (FLEX-01). This enables tracking schema changes and allows workflows to create tables.
Output: FlexVersionService for version tracking, FlexTableNode for workflow integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-flexdb-schema-foundation/01-RESEARCH.md
@.planning/phases/01-flexdb-schema-foundation/01-01-SUMMARY.md

# Schema from Plan 01
@apps/api/src/plugins/workscript/schema/flexdb.schema.ts

# Node patterns to follow
@packages/nodes/src/data/DatabaseNode.ts
@packages/nodes/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FlexVersionService</name>
  <files>apps/api/src/plugins/workscript/services/FlexVersionService.ts</files>
  <action>
Create the version tracking service with:

**Imports:**
```typescript
import { db } from '../../../db';
import { eq, desc } from 'drizzle-orm';
import { createId } from '@paralleldrive/cuid2';
import {
  flexTableVersions,
  FlexTableSchema,
  FlexColumnDefinition,
  SchemaChange,
  FlexTableVersion
} from '../schema/flexdb.schema';
```

**computeSchemaChanges function (pure, export separately):**
```typescript
export function computeSchemaChanges(
  oldSchema: FlexTableSchema | null,
  newSchema: FlexTableSchema
): SchemaChange[]
```

Implementation:
1. Create Map of old columns by name
2. Create Map of new columns by name
3. Find added columns (in new, not in old) -> { type: 'add_column', column: name, details: { after: col } }
4. Find removed columns (in old, not in new) -> { type: 'remove_column', column: name, details: { before: col } }
5. Find modified columns (in both, but JSON.stringify differs) -> { type: 'modify_column', column: name, details: { before: old, after: new } }
6. Return array of changes

**createVersionEntry method:**
```typescript
async createVersionEntry(
  tableId: string,
  previousSchema: FlexTableSchema | null,
  newSchema: FlexTableSchema,
  userId?: string
): Promise<FlexTableVersion>
```

Implementation:
1. Compute changes using computeSchemaChanges
2. Generate ID with createId()
3. Insert into flexTableVersions:
   ```typescript
   await db.insert(flexTableVersions).values({
     id,
     tableId,
     version: newSchema.version,
     previousSchema,
     newSchema,
     changes,
     createdBy: userId
   });
   ```
4. Return inserted record

**getVersionHistory method:**
```typescript
async getVersionHistory(tableId: string): Promise<FlexTableVersion[]>
```
- Query flexTableVersions where tableId matches
- Order by version DESC (newest first)
- Return array of versions

**getVersion method:**
```typescript
async getVersion(tableId: string, version: number): Promise<FlexTableVersion | null>
```
- Find specific version entry

**Export class:**
```typescript
export class FlexVersionService {
  computeSchemaChanges = computeSchemaChanges;
  createVersionEntry = this.createVersionEntry.bind(this);
  getVersionHistory = this.getVersionHistory.bind(this);
  getVersion = this.getVersion.bind(this);
}

export const flexVersionService = new FlexVersionService();
```
  </action>
  <verify>
`bun run typecheck` passes
  </verify>
  <done>
FlexVersionService.ts exists with computeSchemaChanges, createVersionEntry, getVersionHistory methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FlexTableNode</name>
  <files>packages/nodes/src/flexdb/FlexTableNode.ts</files>
  <action>
Create the workflow node for FlexDB table operations:

**Directory:** Create packages/nodes/src/flexdb/ directory if it doesn't exist

**Imports:**
```typescript
import { WorkflowNode } from '@workscript/engine';
import type { ExecutionContext, EdgeMap } from '@workscript/engine';
```

**FlexTableNode class:**
```typescript
export class FlexTableNode extends WorkflowNode {
  metadata = {
    id: 'flex-table',
    name: 'FlexDB Table Operations',
    version: '1.0.0',
    description: 'Create, update, and manage FlexDB tables at runtime',
    inputs: ['operation', 'tableName', 'columns', 'tableId', 'applicationId'],
    outputs: ['tableId', 'schema', 'version', 'table'],
    edgeDescriptions: {
      'success': 'Table operation completed successfully',
      'error': 'Operation failed - check error message',
      'exists': 'Table already exists (on create)',
      'not_found': 'Table not found (on get/update/delete)'
    },
    ai_hints: {
      purpose: 'Create and manage database tables dynamically at runtime',
      when_to_use: 'When you need to define data structures without traditional migrations',
      expected_edges: ['success', 'error', 'exists', 'not_found'],
      example_usage: '{"flex-table": {"operation": "create", "tableName": "customers", "columns": [...], "success?": {...}}}',
      example_config: '{"operation": "create|get|list", "tableName": "string", "columns?": "[ColumnDefinition]", "applicationId": "$.appId"}',
      get_from_state: ['applicationId'],
      post_to_state: ['flexTable', 'flexTableId', 'flexTableSchema']
    }
  };

  async execute(context: ExecutionContext, config?: any): Promise<EdgeMap> {
    const { operation, tableName, columns, tableId, applicationId } = config || {};

    // Resolve state references
    const appId = context.state.applicationId || applicationId;

    if (!appId) {
      return {
        error: () => ({
          error: 'applicationId is required',
          code: 'MISSING_APPLICATION_ID'
        })
      };
    }

    try {
      switch (operation) {
        case 'create':
          return await this.handleCreate(context, appId, tableName, columns, config);

        case 'get':
          return await this.handleGet(context, tableId, appId, tableName);

        case 'list':
          return await this.handleList(context, appId);

        default:
          return {
            error: () => ({
              error: `Unknown operation: ${operation}`,
              code: 'UNKNOWN_OPERATION'
            })
          };
      }
    } catch (err) {
      return {
        error: () => ({
          error: err instanceof Error ? err.message : 'Internal error',
          code: 'INTERNAL_ERROR'
        })
      };
    }
  }

  private async handleCreate(
    context: ExecutionContext,
    applicationId: string,
    tableName: string,
    columns: any[],
    config: any
  ): Promise<EdgeMap> {
    // NOTE: For Phase 1, this is a stub that validates inputs
    // Full implementation connects to FlexDBService in Phase 2+

    if (!tableName) {
      return {
        error: () => ({ error: 'tableName is required', code: 'VALIDATION_ERROR' })
      };
    }

    if (!columns || !Array.isArray(columns) || columns.length === 0) {
      return {
        error: () => ({ error: 'columns array is required and must not be empty', code: 'VALIDATION_ERROR' })
      };
    }

    // Validate table name format
    if (!/^[a-z][a-z0-9_]*$/.test(tableName)) {
      return {
        error: () => ({
          error: 'tableName must be lowercase snake_case (e.g., customer_orders)',
          code: 'VALIDATION_ERROR'
        })
      };
    }

    // Store in context for downstream use
    // In full implementation, this calls FlexDBService.createTable
    const mockTable = {
      id: 'pending-implementation',
      applicationId,
      name: tableName,
      displayName: config.displayName || tableName,
      schema: { columns, version: 1 },
      version: 1
    };

    context.state.flexTable = mockTable;
    context.state.flexTableId = mockTable.id;
    context.state.flexTableSchema = mockTable.schema;

    return {
      success: () => ({
        tableId: mockTable.id,
        table: mockTable,
        schema: mockTable.schema,
        version: mockTable.version
      })
    };
  }

  private async handleGet(
    context: ExecutionContext,
    tableId: string | undefined,
    applicationId: string,
    tableName: string | undefined
  ): Promise<EdgeMap> {
    if (!tableId && !tableName) {
      return {
        error: () => ({ error: 'Either tableId or tableName is required', code: 'VALIDATION_ERROR' })
      };
    }

    // Stub: Full implementation queries FlexDBService
    return {
      not_found: () => ({ error: 'Table not found', code: 'NOT_FOUND' })
    };
  }

  private async handleList(context: ExecutionContext, applicationId: string): Promise<EdgeMap> {
    // Stub: Full implementation queries FlexDBService.listTables
    context.state.flexTables = [];

    return {
      success: () => ({ tables: [], count: 0 })
    };
  }
}

export default FlexTableNode;
```

**JSDoc comments:** Add comprehensive JSDoc explaining:
- Each operation type (create, get, list)
- Config structure with examples
- State variables set (flexTable, flexTableId, flexTableSchema)
- Edge meanings
  </action>
  <verify>
`bun run typecheck` from monorepo root passes
  </verify>
  <done>
FlexTableNode.ts exists with create/get/list operations, proper metadata and ai_hints
  </done>
</task>

<task type="auto">
  <name>Task 3: Register FlexTableNode in Package Exports</name>
  <files>packages/nodes/src/index.ts</files>
  <action>
Update the nodes package index to export FlexTableNode:

1. Add import:
```typescript
import { FlexTableNode } from './flexdb/FlexTableNode';
```

2. Add to ALL_NODES array:
```typescript
export const ALL_NODES = [
  // ... existing nodes
  FlexTableNode,
];
```

3. Add named export:
```typescript
export { FlexTableNode } from './flexdb/FlexTableNode';
```

This registers the node for use in workflows.
  </action>
  <verify>
`bun run build:nodes` succeeds
`bun run typecheck` passes
  </verify>
  <done>
FlexTableNode is registered in ALL_NODES and exported from @workscript/nodes
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Services Index</name>
  <files>apps/api/src/plugins/workscript/services/index.ts</files>
  <action>
Add FlexVersionService export to services index:

```typescript
// Existing exports
export * from './WorkflowService';
export * from './FlexSchemaValidator';
export * from './FlexDBService';

// Version tracking
export * from './FlexVersionService';
```
  </action>
  <verify>
`bun run typecheck` passes
  </verify>
  <done>
FlexVersionService exported from services index
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes with no errors
2. `bun run build:nodes` succeeds
3. FlexVersionService:
   - computeSchemaChanges detects add/remove/modify correctly
   - createVersionEntry inserts record
   - getVersionHistory returns versions in order
4. FlexTableNode:
   - Registered in ALL_NODES
   - Handles 'create', 'get', 'list' operations
   - Returns appropriate edges
5. Services index exports all FlexDB services
</verification>

<success_criteria>
- [ ] FlexVersionService.ts exists with version tracking methods
- [ ] computeSchemaChanges detects add_column, remove_column, modify_column
- [ ] createVersionEntry inserts into flex_table_versions
- [ ] getVersionHistory returns versions in chronological order
- [ ] FlexTableNode.ts exists in packages/nodes/src/flexdb/
- [ ] Node has proper metadata and ai_hints
- [ ] Node handles create, get, list operations
- [ ] FlexTableNode registered in ALL_NODES
- [ ] Services index exports FlexVersionService
- [ ] Type check passes
- [ ] Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-flexdb-schema-foundation/01-03-SUMMARY.md`
</output>
