---
phase: 01-flexdb-schema-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/nodes/src/flexdb/FlexTableNode.ts
  - packages/nodes/src/index.ts
autonomous: true

must_haves:
  truths:
    - "flex-table workflow node can create tables via FlexDBService"
    - "flex-table workflow node can retrieve table by ID or name"
    - "flex-table workflow node can list tables for an application"
    - "Node returns appropriate edges (success, error, exists, not_found)"
  artifacts:
    - path: "packages/nodes/src/flexdb/FlexTableNode.ts"
      provides: "Workflow node for FlexDB table operations"
      exports: ["FlexTableNode"]
      min_lines: 100
  key_links:
    - from: "packages/nodes/src/flexdb/FlexTableNode.ts"
      to: "@workscript/engine"
      via: "extends WorkflowNode"
      pattern: "extends WorkflowNode"
    - from: "packages/nodes/src/flexdb/FlexTableNode.ts"
      to: "apps/api/src/plugins/workscript/services/FlexDBService.ts"
      via: "calls flexDBService methods"
      pattern: "flexDBService\\.(createTable|getTable|listTables)"
---

<objective>
Create the flex-table workflow node that integrates with FlexDBService.

Purpose: Complete Phase 1 by implementing the workflow node interface (FLEX-01). This enables workflows to create and manage FlexDB tables using the service layer built in Plan 02.
Output: FlexTableNode wired to FlexDBService for real table operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-flexdb-schema-foundation/01-RESEARCH.md
@.planning/phases/01-flexdb-schema-foundation/01-02-SUMMARY.md

# Services from Plan 02
@apps/api/src/plugins/workscript/services/FlexDBService.ts
@apps/api/src/plugins/workscript/services/index.ts

# Node patterns to follow
@packages/nodes/src/data/DatabaseNode.ts
@packages/nodes/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FlexTableNode with FlexDBService Integration</name>
  <files>packages/nodes/src/flexdb/FlexTableNode.ts</files>
  <action>
Create the workflow node for FlexDB table operations:

**Directory:** Create packages/nodes/src/flexdb/ directory if it doesn't exist

**Imports:**
```typescript
import { WorkflowNode } from '@workscript/engine';
import type { ExecutionContext, EdgeMap } from '@workscript/engine';
// Import the service - nodes in packages/nodes access API services via dynamic import or shared interface
// For server-side execution, the API injects the service
```

**Service Access Pattern:**
Since FlexTableNode runs server-side within the API, it can access FlexDBService directly. Use one of these patterns:

Option A - Direct import (if packages/nodes can import from apps/api):
```typescript
import { flexDBService } from '../../../../apps/api/src/plugins/workscript/services/FlexDBService';
```

Option B - Context injection (recommended - service passed via ExecutionContext):
```typescript
// The API's workflow executor sets context.services.flexDB before running nodes
const flexDBService = context.services?.flexDB;
if (!flexDBService) {
  return { error: () => ({ error: 'FlexDBService not available', code: 'SERVICE_UNAVAILABLE' }) };
}
```

Use Option B - it maintains clean separation between packages.

**FlexTableNode class:**
```typescript
export class FlexTableNode extends WorkflowNode {
  metadata = {
    id: 'flex-table',
    name: 'FlexDB Table Operations',
    version: '1.0.0',
    description: 'Create, update, and manage FlexDB tables at runtime',
    inputs: ['operation', 'tableName', 'columns', 'tableId', 'applicationId'],
    outputs: ['tableId', 'schema', 'version', 'table'],
    edgeDescriptions: {
      'success': 'Table operation completed successfully',
      'error': 'Operation failed - check error message',
      'exists': 'Table already exists (on create)',
      'not_found': 'Table not found (on get/update/delete)'
    },
    ai_hints: {
      purpose: 'Create and manage database tables dynamically at runtime',
      when_to_use: 'When you need to define data structures without traditional migrations',
      expected_edges: ['success', 'error', 'exists', 'not_found'],
      example_usage: '{"flex-table": {"operation": "create", "tableName": "customers", "columns": [...], "success?": {...}}}',
      example_config: '{"operation": "create|get|list", "tableName": "string", "columns?": "[ColumnDefinition]", "applicationId": "$.appId"}',
      get_from_state: ['applicationId'],
      post_to_state: ['flexTable', 'flexTableId', 'flexTableSchema']
    }
  };

  async execute(context: ExecutionContext, config?: any): Promise<EdgeMap> {
    const { operation, tableName, columns, tableId, applicationId, displayName } = config || {};

    // Get service from context (injected by API)
    const flexDBService = context.services?.flexDB;
    if (!flexDBService) {
      return {
        error: () => ({
          error: 'FlexDBService not available in execution context',
          code: 'SERVICE_UNAVAILABLE'
        })
      };
    }

    // Resolve state references
    const appId = context.state.applicationId || applicationId;

    if (!appId) {
      return {
        error: () => ({
          error: 'applicationId is required',
          code: 'MISSING_APPLICATION_ID'
        })
      };
    }

    try {
      switch (operation) {
        case 'create':
          return await this.handleCreate(context, flexDBService, appId, tableName, columns, displayName);

        case 'get':
          return await this.handleGet(context, flexDBService, tableId, appId, tableName);

        case 'list':
          return await this.handleList(context, flexDBService, appId);

        default:
          return {
            error: () => ({
              error: `Unknown operation: ${operation}`,
              code: 'UNKNOWN_OPERATION'
            })
          };
      }
    } catch (err) {
      return {
        error: () => ({
          error: err instanceof Error ? err.message : 'Internal error',
          code: 'INTERNAL_ERROR'
        })
      };
    }
  }

  private async handleCreate(
    context: ExecutionContext,
    flexDBService: any,
    applicationId: string,
    tableName: string,
    columns: any[],
    displayName?: string
  ): Promise<EdgeMap> {
    if (!tableName) {
      return {
        error: () => ({ error: 'tableName is required', code: 'VALIDATION_ERROR' })
      };
    }

    if (!columns || !Array.isArray(columns) || columns.length === 0) {
      return {
        error: () => ({ error: 'columns array is required and must not be empty', code: 'VALIDATION_ERROR' })
      };
    }

    // Call FlexDBService.createTable
    const result = await flexDBService.createTable(applicationId, tableName, columns, {
      displayName,
      createdBy: context.state.userId
    });

    if (!result.success) {
      if (result.code === 'DUPLICATE') {
        return {
          exists: () => ({
            error: result.error,
            code: result.code
          })
        };
      }
      return {
        error: () => ({
          error: result.error,
          code: result.code
        })
      };
    }

    // Store in context for downstream use
    context.state.flexTable = result.data;
    context.state.flexTableId = result.data.id;
    context.state.flexTableSchema = result.data.schema;

    return {
      success: () => ({
        tableId: result.data.id,
        table: result.data,
        schema: result.data.schema,
        version: result.data.version
      })
    };
  }

  private async handleGet(
    context: ExecutionContext,
    flexDBService: any,
    tableId: string | undefined,
    applicationId: string,
    tableName: string | undefined
  ): Promise<EdgeMap> {
    if (!tableId && !tableName) {
      return {
        error: () => ({ error: 'Either tableId or tableName is required', code: 'VALIDATION_ERROR' })
      };
    }

    // Get by ID or by name
    const result = tableId
      ? await flexDBService.getTable(tableId)
      : await flexDBService.getTableByName(applicationId, tableName);

    if (!result.success) {
      if (result.code === 'NOT_FOUND') {
        return {
          not_found: () => ({
            error: result.error,
            code: result.code
          })
        };
      }
      return {
        error: () => ({
          error: result.error,
          code: result.code
        })
      };
    }

    context.state.flexTable = result.data;
    context.state.flexTableId = result.data.id;
    context.state.flexTableSchema = result.data.schema;

    return {
      success: () => ({
        tableId: result.data.id,
        table: result.data,
        schema: result.data.schema,
        version: result.data.version
      })
    };
  }

  private async handleList(
    context: ExecutionContext,
    flexDBService: any,
    applicationId: string
  ): Promise<EdgeMap> {
    const tables = await flexDBService.listTables(applicationId);

    context.state.flexTables = tables;

    return {
      success: () => ({
        tables,
        count: tables.length
      })
    };
  }
}

export default FlexTableNode;
```

**JSDoc comments:** Add comprehensive JSDoc explaining:
- Each operation type (create, get, list)
- Config structure with examples
- State variables set (flexTable, flexTableId, flexTableSchema)
- Edge meanings
- Service injection requirement
  </action>
  <verify>
`bun run typecheck` from monorepo root passes
  </verify>
  <done>
FlexTableNode.ts exists with create/get/list operations that call FlexDBService methods, proper metadata and ai_hints
  </done>
</task>

<task type="auto">
  <name>Task 2: Register FlexTableNode in Package Exports</name>
  <files>packages/nodes/src/index.ts</files>
  <action>
Update the nodes package index to export FlexTableNode:

1. Add import:
```typescript
import { FlexTableNode } from './flexdb/FlexTableNode';
```

2. Add to ALL_NODES array:
```typescript
export const ALL_NODES = [
  // ... existing nodes
  FlexTableNode,
];
```

3. Add named export:
```typescript
export { FlexTableNode } from './flexdb/FlexTableNode';
```

This registers the node for use in workflows.
  </action>
  <verify>
`bun run build:nodes` succeeds
`bun run typecheck` passes
  </verify>
  <done>
FlexTableNode is registered in ALL_NODES and exported from @workscript/nodes
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes with no errors
2. `bun run build:nodes` succeeds
3. FlexTableNode:
   - Registered in ALL_NODES
   - Handles 'create', 'get', 'list' operations
   - Returns appropriate edges (success, error, exists, not_found)
   - handleCreate calls flexDBService.createTable (key link wired)
   - handleGet calls flexDBService.getTable or getTableByName
   - handleList calls flexDBService.listTables
   - Gets service from context.services.flexDB
</verification>

<success_criteria>
- [ ] FlexTableNode.ts exists in packages/nodes/src/flexdb/
- [ ] Node has proper metadata and ai_hints
- [ ] Node handles create, get, list operations
- [ ] handleCreate calls flexDBService.createTable (key link wired)
- [ ] handleGet calls flexDBService.getTable/getTableByName
- [ ] handleList calls flexDBService.listTables
- [ ] Node uses context.services.flexDB pattern for service access
- [ ] FlexTableNode registered in ALL_NODES
- [ ] Type check passes
- [ ] Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-flexdb-schema-foundation/01-03-SUMMARY.md`
</output>
