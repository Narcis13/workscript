# Tasks Document

## Generated from Specification

This is a placeholder for the tasks document that would be generated by an AI agent.

### How to use this:

1. Copy the prompt from: tasks-prompt.md
2. Provide the following context to your AI agent:

---
# Tasks Generation Prompt

You are an expert project manager and software engineer. Your task is to create a comprehensive implementation plan based on a specification, requirements, and technical design.

## Input
You will receive:
1. A software specification
2. A requirements document with user stories
3. A technical design document with architecture

## Your Task
Create an implementation task list following this exact format:

### 1. Document Header
Start with:
```markdown
# Implementation Plan
```

### 2. Task Format
Each task must follow this structure:
```markdown
- [ ] [Number]. [Task Description]
  - [Additional details or subtasks if needed]
  - _Requirements: [Requirement numbers this task implements]_
```

### 3. Task Organization Principles

#### Task Ordering
Order tasks by:
1. **Dependencies** - Prerequisites come first
2. **Foundation** - Core infrastructure before features
3. **Risk** - High-risk items early for validation
4. **Value** - Critical features before nice-to-haves

#### Task Grouping
Group related tasks:
1. **Setup & Infrastructure** (tasks 1-X)
2. **Core Components** (tasks X-Y)
3. **Feature Implementation** (tasks Y-Z)
4. **Testing & Validation** (tasks Z-N)
5. **Documentation & Deployment** (final tasks)

### 4. Task Breakdown Guidelines

#### Task Size
- Each task should be completable in 0.5-4 hours
- Large features should be broken into subtasks
- Tasks should have clear completion criteria

#### Task Types to Include

1. **Setup Tasks**
   - Project initialization
   - Dependency installation
   - Configuration setup
   - Development environment

2. **Type/Interface Tasks**
   - Define data models
   - Create interfaces
   - Set up type systems
   - API contracts

3. **Infrastructure Tasks**
   - Database setup
   - Authentication system
   - Logging framework
   - Error handling setup

4. **Component Tasks**
   - Core class implementation
   - Service creation
   - Module development
   - Integration layers

5. **Feature Tasks**
   - User-facing features
   - Business logic
   - API endpoints
   - UI components

6. **Testing Tasks**
   - Unit test creation
   - Integration tests
   - End-to-end tests
   - Performance tests

7. **Documentation Tasks**
   - API documentation
   - User guides
   - Developer docs
   - Deployment guides

8. **Deployment Tasks**
   - Build configuration
   - CI/CD setup
   - Environment setup
   - Production deployment

### 5. Task Description Rules

Each task description should:
- Start with an action verb (Create, Implement, Add, Configure, Test, etc.)
- Be specific about what needs to be done
- Reference specific components from the design
- Include acceptance criteria when not obvious

### 6. Requirement Linking

For each task:
- List which requirements it fulfills
- Use requirement numbers from the requirements document
- Format: `_Requirements: 1.1, 1.2, 3.4_`
- Some tasks may not link to requirements (infrastructure, testing)

### 7. Example Output

```markdown
# Implementation Plan

- [ ] 1. Set up project structure and initialize monorepo
  - Create directory structure for packages
  - Initialize package.json files
  - Configure TypeScript and build tools
  - _Requirements: N/A (infrastructure)_

- [ ] 2. Create shared type definitions and interfaces
  - Define User, Task, and Project interfaces
  - Create API request/response types
  - Set up validation schemas
  - _Requirements: 2.1, 2.2_

- [ ] 3. Implement user authentication service
  - Create JWT token generation
  - Implement password hashing
  - Add session management
  - _Requirements: 3.1, 3.2, 3.3_
```

### 8. Special Considerations

#### Testing Tasks
- Include unit tests with implementation tasks
- Separate integration testing tasks
- Add performance testing where needed

#### Documentation Tasks
- API documentation alongside endpoint creation
- User documentation after feature completion
- Developer guides with setup tasks

#### Review Points
Add review/validation tasks at key milestones:
- After core infrastructure
- After major features
- Before deployment

### 9. Task Validation Checklist

Before finalizing, ensure:
- [ ] All requirements have corresponding tasks
- [ ] Tasks are in logical dependency order
- [ ] Each task is clearly defined and actionable
- [ ] High-risk items are addressed early
- [ ] Testing tasks are included throughout
- [ ] Documentation tasks are included
- [ ] Tasks are numbered sequentially
- [ ] Requirement links are accurate

### 10. Progress Tracking

The checkbox format allows for:
- Easy progress visualization
- Git-friendly task tracking
- Clear completion status
- Simple handoff between developers

## Guidelines for Complex Projects

### For Large Systems
- Break into phases or milestones
- Add checkpoint tasks between phases
- Include integration tasks between components
- Plan for incremental delivery

### For Parallel Development
- Identify tasks that can be done concurrently
- Note dependencies explicitly
- Group by developer skill sets
- Plan integration points

Generate a complete implementation plan based on the specification, requirements, and design provided. Ensure all tasks are actionable, properly ordered, and linked to requirements where applicable.

---

### Input Context:

## Specification

# Task Management API Specification

## Overview

A RESTful API for managing tasks with user authentication, task CRUD operations, team collaboration features, and real-time updates. The system will support individual users and teams, with role-based access control and comprehensive task tracking capabilities.

## Core Features

### User Management
- User registration with email verification
- Secure authentication using JWT tokens
- Password reset functionality
- User profile management
- Role-based access control (Admin, Manager, Member)

### Task Management
- Create, read, update, and delete tasks
- Task properties: title, description, status, priority, due date, assignee
- Task statuses: Todo, In Progress, Review, Done
- Task priorities: Low, Medium, High, Critical
- File attachments support
- Task comments and activity history
- Task labels/tags for categorization

### Team Collaboration
- Create and manage teams
- Invite team members via email
- Assign tasks to team members
- Team-wide task visibility
- Permission levels within teams
- Team dashboards and analytics

### Real-time Features
- WebSocket connections for live updates
- Real-time task status changes
- Instant notifications for task assignments
- Live collaboration on task comments

### Search and Filtering
- Full-text search across tasks
- Filter by status, priority, assignee, due date
- Sort by multiple criteria
- Saved filter presets

## Technical Requirements

### Technology Stack
- Backend: Node.js with TypeScript
- Framework: Express.js or Fastify
- Database: PostgreSQL for relational data
- Cache: Redis for session management and real-time features
- Authentication: JWT with refresh tokens
- Real-time: Socket.io
- Testing: Jest for unit tests, Supertest for integration tests

### API Standards
- RESTful design principles
- JSON request/response format
- Consistent error handling
- API versioning (v1)
- OpenAPI/Swagger documentation
- Rate limiting for API protection

### Performance Requirements
- API response time < 200ms for standard operations
- Support for 1000 concurrent users
- Real-time updates delivered within 100ms
- Database queries optimized with proper indexing
- Pagination for large datasets (default 20 items)

### Security Requirements
- HTTPS only
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CORS configuration
- API key authentication for service-to-service communication
- Audit logging for sensitive operations

## Data Models

### User
- id (UUID)
- email (unique)
- password (hashed)
- firstName
- lastName
- role
- emailVerified
- createdAt
- updatedAt

### Team
- id (UUID)
- name
- description
- ownerId (User reference)
- createdAt
- updatedAt

### Task
- id (UUID)
- title
- description
- status
- priority
- dueDate
- assigneeId (User reference)
- teamId (Team reference)
- creatorId (User reference)
- labels (array)
- createdAt
- updatedAt
- completedAt

### TeamMember
- teamId (Team reference)
- userId (User reference)
- role (Admin, Manager, Member)
- joinedAt

### Comment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- content
- createdAt
- updatedAt

### Attachment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- fileName
- fileSize
- mimeType
- url
- uploadedAt

## API Endpoints Overview

### Authentication
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- POST /api/v1/auth/refresh
- POST /api/v1/auth/logout
- POST /api/v1/auth/forgot-password
- POST /api/v1/auth/reset-password
- GET /api/v1/auth/verify-email

### Users
- GET /api/v1/users/profile
- PUT /api/v1/users/profile
- DELETE /api/v1/users/profile

### Teams
- POST /api/v1/teams
- GET /api/v1/teams
- GET /api/v1/teams/:id
- PUT /api/v1/teams/:id
- DELETE /api/v1/teams/:id
- POST /api/v1/teams/:id/invite
- GET /api/v1/teams/:id/members
- DELETE /api/v1/teams/:id/members/:userId

### Tasks
- POST /api/v1/tasks
- GET /api/v1/tasks
- GET /api/v1/tasks/:id
- PUT /api/v1/tasks/:id
- DELETE /api/v1/tasks/:id
- POST /api/v1/tasks/:id/comments
- GET /api/v1/tasks/:id/comments
- POST /api/v1/tasks/:id/attachments
- GET /api/v1/tasks/:id/attachments

### Search
- GET /api/v1/search/tasks

### WebSocket Events
- task:created
- task:updated
- task:deleted
- task:assigned
- comment:added
- user:joined
- user:left

## Success Criteria

1. All CRUD operations for tasks functioning correctly
2. User authentication and authorization working securely
3. Team collaboration features operational
4. Real-time updates delivered reliably
5. API performance meeting specified benchmarks
6. Comprehensive test coverage (>80%)
7. API documentation complete and accurate
8. Security best practices implemented
9. Monitoring and logging in place
10. Deployment pipeline configured

## requirements.md

# Requirements Document

## Generated from Specification

This is a placeholder for the requirements document that would be generated by an AI agent.

### How to use this:

1. Copy the prompt from: requirements-prompt.md
2. Provide the following context to your AI agent:

---
# Requirements Generation Prompt

You are an expert software requirements analyst. Your task is to transform a software specification into a comprehensive requirements document with user stories and acceptance criteria.

## Input
You will receive a software specification document that describes what needs to be built.

## Your Task
Create a requirements document following this exact structure:

### 1. Document Header
Start with:
```markdown
# Requirements Document

## Introduction

[Brief 2-3 paragraph introduction explaining what the system does and the purpose of this requirements document]

## Requirements
```

### 2. Requirements Format
For each requirement, use this structure:

```markdown
### Requirement [Number]

**User Story:** As a [type of user], I want [functionality], so that [business value].

#### Acceptance Criteria

1. WHEN [condition/action] THEN [expected result]
2. WHEN [condition/action] THEN [expected result]
3. IF [condition] THEN [expected result]
4. WHEN [condition/action] THEN [expected result]
```

### 3. Requirements Guidelines

#### User Story Rules:
- Start with "As a..." format
- Identify specific user types (developer, admin, end user, etc.)
- Focus on the "what" not the "how"
- Include clear business value in "so that" clause
- Keep stories small and focused on single functionality

#### Acceptance Criteria Rules:
- Use WHEN/THEN format for actions and expected outcomes
- Use IF/THEN format for conditional requirements
- Make criteria specific and testable
- Include both positive and negative test cases
- Cover edge cases and error conditions
- Number each criterion for easy reference

### 4. Coverage Areas
Ensure requirements cover:

1. **Core Functionality** - Main features described in the spec
2. **User Management** - Authentication, authorization, roles (if applicable)
3. **Data Operations** - CRUD operations, data validation, persistence
4. **Integration Points** - APIs, external systems, data exchange
5. **Error Handling** - Invalid inputs, system failures, recovery
6. **Performance** - Response times, concurrent users, data limits
7. **Security** - Access control, data protection, audit trails
8. **Usability** - User experience, accessibility, help systems

### 5. Requirements Numbering
- Number requirements sequentially (1, 2, 3...)
- Group related requirements together
- Use descriptive requirement titles after numbers

### 6. Quality Checks
Before finalizing, ensure each requirement:
- [ ] Has a clear user story with identified user type
- [ ] Includes 3-5 specific acceptance criteria
- [ ] Is testable and measurable
- [ ] Doesn't specify implementation details
- [ ] Relates to specification goals
- [ ] Has no ambiguous terms ("fast", "easy", "good")

## Output Example

```markdown
### Requirement 1

**User Story:** As a developer, I want to define workflows in JSON format, so that I can create executable business processes without writing complex code.

#### Acceptance Criteria

1. WHEN a JSON workflow file is provided THEN the system SHALL parse and validate the workflow structure
2. WHEN the workflow contains required fields (id, name, version, workflow) THEN the system SHALL accept the workflow definition
3. IF the workflow contains invalid JSON syntax THEN the system SHALL return a descriptive error message
4. WHEN the workflow references non-existent nodes THEN the system SHALL return a validation error before execution
```

## Special Instructions

1. **Be Comprehensive** - Extract ALL functionality mentioned in the spec
2. **Be Specific** - Avoid vague language; use concrete, measurable criteria
3. **Think Testing** - Write criteria that a QA engineer could turn into test cases
4. **Consider Edge Cases** - What could go wrong? What are the limits?
5. **Maintain Consistency** - Use consistent terminology throughout

## Final Checklist
- [ ] All major features from spec are covered
- [ ] Each requirement has a complete user story
- [ ] All acceptance criteria are testable
- [ ] Requirements are numbered sequentially
- [ ] No implementation details are specified
- [ ] Error cases are covered
- [ ] Performance requirements are included where relevant

Generate a complete requirements document based on the specification provided. Be thorough and systematic in your analysis.

---

### Input Context:

## Specification

# Task Management API Specification

## Overview

A RESTful API for managing tasks with user authentication, task CRUD operations, team collaboration features, and real-time updates. The system will support individual users and teams, with role-based access control and comprehensive task tracking capabilities.

## Core Features

### User Management
- User registration with email verification
- Secure authentication using JWT tokens
- Password reset functionality
- User profile management
- Role-based access control (Admin, Manager, Member)

### Task Management
- Create, read, update, and delete tasks
- Task properties: title, description, status, priority, due date, assignee
- Task statuses: Todo, In Progress, Review, Done
- Task priorities: Low, Medium, High, Critical
- File attachments support
- Task comments and activity history
- Task labels/tags for categorization

### Team Collaboration
- Create and manage teams
- Invite team members via email
- Assign tasks to team members
- Team-wide task visibility
- Permission levels within teams
- Team dashboards and analytics

### Real-time Features
- WebSocket connections for live updates
- Real-time task status changes
- Instant notifications for task assignments
- Live collaboration on task comments

### Search and Filtering
- Full-text search across tasks
- Filter by status, priority, assignee, due date
- Sort by multiple criteria
- Saved filter presets

## Technical Requirements

### Technology Stack
- Backend: Node.js with TypeScript
- Framework: Express.js or Fastify
- Database: PostgreSQL for relational data
- Cache: Redis for session management and real-time features
- Authentication: JWT with refresh tokens
- Real-time: Socket.io
- Testing: Jest for unit tests, Supertest for integration tests

### API Standards
- RESTful design principles
- JSON request/response format
- Consistent error handling
- API versioning (v1)
- OpenAPI/Swagger documentation
- Rate limiting for API protection

### Performance Requirements
- API response time < 200ms for standard operations
- Support for 1000 concurrent users
- Real-time updates delivered within 100ms
- Database queries optimized with proper indexing
- Pagination for large datasets (default 20 items)

### Security Requirements
- HTTPS only
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CORS configuration
- API key authentication for service-to-service communication
- Audit logging for sensitive operations

## Data Models

### User
- id (UUID)
- email (unique)
- password (hashed)
- firstName
- lastName
- role
- emailVerified
- createdAt
- updatedAt

### Team
- id (UUID)
- name
- description
- ownerId (User reference)
- createdAt
- updatedAt

### Task
- id (UUID)
- title
- description
- status
- priority
- dueDate
- assigneeId (User reference)
- teamId (Team reference)
- creatorId (User reference)
- labels (array)
- createdAt
- updatedAt
- completedAt

### TeamMember
- teamId (Team reference)
- userId (User reference)
- role (Admin, Manager, Member)
- joinedAt

### Comment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- content
- createdAt
- updatedAt

### Attachment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- fileName
- fileSize
- mimeType
- url
- uploadedAt

## API Endpoints Overview

### Authentication
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- POST /api/v1/auth/refresh
- POST /api/v1/auth/logout
- POST /api/v1/auth/forgot-password
- POST /api/v1/auth/reset-password
- GET /api/v1/auth/verify-email

### Users
- GET /api/v1/users/profile
- PUT /api/v1/users/profile
- DELETE /api/v1/users/profile

### Teams
- POST /api/v1/teams
- GET /api/v1/teams
- GET /api/v1/teams/:id
- PUT /api/v1/teams/:id
- DELETE /api/v1/teams/:id
- POST /api/v1/teams/:id/invite
- GET /api/v1/teams/:id/members
- DELETE /api/v1/teams/:id/members/:userId

### Tasks
- POST /api/v1/tasks
- GET /api/v1/tasks
- GET /api/v1/tasks/:id
- PUT /api/v1/tasks/:id
- DELETE /api/v1/tasks/:id
- POST /api/v1/tasks/:id/comments
- GET /api/v1/tasks/:id/comments
- POST /api/v1/tasks/:id/attachments
- GET /api/v1/tasks/:id/attachments

### Search
- GET /api/v1/search/tasks

### WebSocket Events
- task:created
- task:updated
- task:deleted
- task:assigned
- comment:added
- user:joined
- user:left

## Success Criteria

1. All CRUD operations for tasks functioning correctly
2. User authentication and authorization working securely
3. Team collaboration features operational
4. Real-time updates delivered reliably
5. API performance meeting specified benchmarks
6. Comprehensive test coverage (>80%)
7. API documentation complete and accurate
8. Security best practices implemented
9. Monitoring and logging in place
10. Deployment pipeline configured



### Instructions:
Ask your AI agent to generate the requirements document based on the prompt and context above.

---

Note: In a production environment, this script would integrate with an AI API (like Claude, OpenAI, etc.) to automatically generate this content.

## design.md

# Design Document

## Generated from Specification

This is a placeholder for the design document that would be generated by an AI agent.

### How to use this:

1. Copy the prompt from: design-prompt.md
2. Provide the following context to your AI agent:

---
# Design Generation Prompt

You are an expert software architect. Your task is to create a comprehensive technical design document based on a software specification and requirements document.

## Input
You will receive:
1. A software specification describing what needs to be built
2. A requirements document with user stories and acceptance criteria

## Your Task
Create a technical design document following this exact structure:

### 1. Document Header
Start with:
```markdown
# Design Document

## Overview

[2-3 paragraph high-level description of the system architecture and key design decisions]

## Architecture
```

### 2. Architecture Section
Include:

#### High-Level Architecture
```markdown
### High-Level Architecture

[Description of overall system architecture]

```mermaid
graph TB
    [Create architecture diagram showing major components and data flow]
```
```

#### Component Architecture
```markdown
### Component Architecture

[Detailed breakdown of system components]

```mermaid
graph LR
    [Create detailed component diagram]
```
```

### 3. Components and Interfaces Section

```markdown
## Components and Interfaces

### Core Interfaces ([language]/src/types/)

#### [Interface Name]
```[language]
[Define key interfaces, abstract classes, or protocols]
```

### [Component Name] ([location])

#### [Class/Module Name]
```[language]
[Define main classes with key methods and properties]
```
```

### 4. Data Models Section

```markdown
## Data Models

### [Model Name]

[Description of the data model]

#### Schema Definition
```[language/json/sql]
[Define data structure/schema]
```

### Data Flow
```mermaid
[Create data flow diagram if complex]
```
```

### 5. Key Design Patterns

For each major component/feature:
- Identify design patterns used
- Explain architectural decisions
- Document key algorithms
- Show sequence diagrams for complex flows

### 6. Error Handling

```markdown
## Error Handling

### Error Categories

1. **[Category Name]**: [Description and examples]
2. **[Category Name]**: [Description and examples]

### Error Handling Strategy

[Define overall approach to error handling]

### Recovery Mechanisms

[Describe how system recovers from various error conditions]
```

### 7. Testing Strategy

```markdown
## Testing Strategy

### Unit Testing

[Approach to unit testing, key areas to test]

### Integration Testing

[Integration test scenarios and approach]

### Test Data Strategy

```[language]
[Example test data structures or generators]
```

### Performance Testing

[Performance test scenarios and benchmarks]
```

### 8. API Design (if applicable)

```markdown
## API Design

### REST Endpoints

```[language/yaml]
[Define API endpoints with request/response formats]
```

### Error Response Format

```[language/json]
[Standard error response structure]
```
```

### 9. Implementation Considerations

```markdown
## Implementation Considerations

### Performance Optimizations

[List specific optimizations needed]

### Security Considerations

[Security measures and best practices]

### Scalability Design

[How system will scale]

### Development Workflow

[Development process, tooling, deployment]
```

### 10. Technology Stack

Based on the specification, choose appropriate:
- Programming language(s)
- Frameworks
- Databases
- External services
- Development tools

## Design Guidelines

1. **Match Requirements** - Ensure every requirement is addressed in the design
2. **Be Specific** - Include concrete interfaces, not just descriptions
3. **Consider Scale** - Design for growth and performance
4. **Think Modular** - Create reusable, testable components
5. **Document Decisions** - Explain why, not just what

## Diagram Guidelines

### Use Mermaid diagrams for:
- System architecture (graph TB/LR)
- Component relationships (graph)
- Sequence flows (sequenceDiagram)
- Data flows (flowchart)
- State machines (stateDiagram)

### Diagram Best Practices:
- Keep diagrams focused on one aspect
- Use clear, descriptive labels
- Show data flow direction
- Include external systems
- Use consistent notation

## Code Examples

When showing code:
- Use the project's specified language
- Show realistic interfaces and signatures
- Include key type definitions
- Add brief comments for clarity
- Focus on structure, not implementation

## Quality Checks

Before finalizing, ensure:
- [ ] All requirements have corresponding design elements
- [ ] Architecture is clear and modular
- [ ] Interfaces are well-defined
- [ ] Error handling is comprehensive
- [ ] Testing approach is thorough
- [ ] Performance considerations are addressed
- [ ] Security is built-in, not bolted-on
- [ ] Design is feasible with chosen technology

## Special Considerations

1. **Frontend/Backend Split** - If applicable, clearly separate concerns
2. **Async Operations** - Design for concurrent operations
3. **State Management** - Define how state is managed and persisted
4. **Integration Points** - Clearly define external dependencies
5. **Deployment** - Consider deployment architecture
6. **Monitoring** - Include observability in design

Generate a complete technical design document based on the specification and requirements provided. Focus on creating a practical, implementable design that addresses all requirements while maintaining good software engineering principles.

---

### Input Context:

## Specification

# Task Management API Specification

## Overview

A RESTful API for managing tasks with user authentication, task CRUD operations, team collaboration features, and real-time updates. The system will support individual users and teams, with role-based access control and comprehensive task tracking capabilities.

## Core Features

### User Management
- User registration with email verification
- Secure authentication using JWT tokens
- Password reset functionality
- User profile management
- Role-based access control (Admin, Manager, Member)

### Task Management
- Create, read, update, and delete tasks
- Task properties: title, description, status, priority, due date, assignee
- Task statuses: Todo, In Progress, Review, Done
- Task priorities: Low, Medium, High, Critical
- File attachments support
- Task comments and activity history
- Task labels/tags for categorization

### Team Collaboration
- Create and manage teams
- Invite team members via email
- Assign tasks to team members
- Team-wide task visibility
- Permission levels within teams
- Team dashboards and analytics

### Real-time Features
- WebSocket connections for live updates
- Real-time task status changes
- Instant notifications for task assignments
- Live collaboration on task comments

### Search and Filtering
- Full-text search across tasks
- Filter by status, priority, assignee, due date
- Sort by multiple criteria
- Saved filter presets

## Technical Requirements

### Technology Stack
- Backend: Node.js with TypeScript
- Framework: Express.js or Fastify
- Database: PostgreSQL for relational data
- Cache: Redis for session management and real-time features
- Authentication: JWT with refresh tokens
- Real-time: Socket.io
- Testing: Jest for unit tests, Supertest for integration tests

### API Standards
- RESTful design principles
- JSON request/response format
- Consistent error handling
- API versioning (v1)
- OpenAPI/Swagger documentation
- Rate limiting for API protection

### Performance Requirements
- API response time < 200ms for standard operations
- Support for 1000 concurrent users
- Real-time updates delivered within 100ms
- Database queries optimized with proper indexing
- Pagination for large datasets (default 20 items)

### Security Requirements
- HTTPS only
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CORS configuration
- API key authentication for service-to-service communication
- Audit logging for sensitive operations

## Data Models

### User
- id (UUID)
- email (unique)
- password (hashed)
- firstName
- lastName
- role
- emailVerified
- createdAt
- updatedAt

### Team
- id (UUID)
- name
- description
- ownerId (User reference)
- createdAt
- updatedAt

### Task
- id (UUID)
- title
- description
- status
- priority
- dueDate
- assigneeId (User reference)
- teamId (Team reference)
- creatorId (User reference)
- labels (array)
- createdAt
- updatedAt
- completedAt

### TeamMember
- teamId (Team reference)
- userId (User reference)
- role (Admin, Manager, Member)
- joinedAt

### Comment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- content
- createdAt
- updatedAt

### Attachment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- fileName
- fileSize
- mimeType
- url
- uploadedAt

## API Endpoints Overview

### Authentication
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- POST /api/v1/auth/refresh
- POST /api/v1/auth/logout
- POST /api/v1/auth/forgot-password
- POST /api/v1/auth/reset-password
- GET /api/v1/auth/verify-email

### Users
- GET /api/v1/users/profile
- PUT /api/v1/users/profile
- DELETE /api/v1/users/profile

### Teams
- POST /api/v1/teams
- GET /api/v1/teams
- GET /api/v1/teams/:id
- PUT /api/v1/teams/:id
- DELETE /api/v1/teams/:id
- POST /api/v1/teams/:id/invite
- GET /api/v1/teams/:id/members
- DELETE /api/v1/teams/:id/members/:userId

### Tasks
- POST /api/v1/tasks
- GET /api/v1/tasks
- GET /api/v1/tasks/:id
- PUT /api/v1/tasks/:id
- DELETE /api/v1/tasks/:id
- POST /api/v1/tasks/:id/comments
- GET /api/v1/tasks/:id/comments
- POST /api/v1/tasks/:id/attachments
- GET /api/v1/tasks/:id/attachments

### Search
- GET /api/v1/search/tasks

### WebSocket Events
- task:created
- task:updated
- task:deleted
- task:assigned
- comment:added
- user:joined
- user:left

## Success Criteria

1. All CRUD operations for tasks functioning correctly
2. User authentication and authorization working securely
3. Team collaboration features operational
4. Real-time updates delivered reliably
5. API performance meeting specified benchmarks
6. Comprehensive test coverage (>80%)
7. API documentation complete and accurate
8. Security best practices implemented
9. Monitoring and logging in place
10. Deployment pipeline configured

## requirements.md

# Requirements Document

## Generated from Specification

This is a placeholder for the requirements document that would be generated by an AI agent.

### How to use this:

1. Copy the prompt from: requirements-prompt.md
2. Provide the following context to your AI agent:

---
# Requirements Generation Prompt

You are an expert software requirements analyst. Your task is to transform a software specification into a comprehensive requirements document with user stories and acceptance criteria.

## Input
You will receive a software specification document that describes what needs to be built.

## Your Task
Create a requirements document following this exact structure:

### 1. Document Header
Start with:
```markdown
# Requirements Document

## Introduction

[Brief 2-3 paragraph introduction explaining what the system does and the purpose of this requirements document]

## Requirements
```

### 2. Requirements Format
For each requirement, use this structure:

```markdown
### Requirement [Number]

**User Story:** As a [type of user], I want [functionality], so that [business value].

#### Acceptance Criteria

1. WHEN [condition/action] THEN [expected result]
2. WHEN [condition/action] THEN [expected result]
3. IF [condition] THEN [expected result]
4. WHEN [condition/action] THEN [expected result]
```

### 3. Requirements Guidelines

#### User Story Rules:
- Start with "As a..." format
- Identify specific user types (developer, admin, end user, etc.)
- Focus on the "what" not the "how"
- Include clear business value in "so that" clause
- Keep stories small and focused on single functionality

#### Acceptance Criteria Rules:
- Use WHEN/THEN format for actions and expected outcomes
- Use IF/THEN format for conditional requirements
- Make criteria specific and testable
- Include both positive and negative test cases
- Cover edge cases and error conditions
- Number each criterion for easy reference

### 4. Coverage Areas
Ensure requirements cover:

1. **Core Functionality** - Main features described in the spec
2. **User Management** - Authentication, authorization, roles (if applicable)
3. **Data Operations** - CRUD operations, data validation, persistence
4. **Integration Points** - APIs, external systems, data exchange
5. **Error Handling** - Invalid inputs, system failures, recovery
6. **Performance** - Response times, concurrent users, data limits
7. **Security** - Access control, data protection, audit trails
8. **Usability** - User experience, accessibility, help systems

### 5. Requirements Numbering
- Number requirements sequentially (1, 2, 3...)
- Group related requirements together
- Use descriptive requirement titles after numbers

### 6. Quality Checks
Before finalizing, ensure each requirement:
- [ ] Has a clear user story with identified user type
- [ ] Includes 3-5 specific acceptance criteria
- [ ] Is testable and measurable
- [ ] Doesn't specify implementation details
- [ ] Relates to specification goals
- [ ] Has no ambiguous terms ("fast", "easy", "good")

## Output Example

```markdown
### Requirement 1

**User Story:** As a developer, I want to define workflows in JSON format, so that I can create executable business processes without writing complex code.

#### Acceptance Criteria

1. WHEN a JSON workflow file is provided THEN the system SHALL parse and validate the workflow structure
2. WHEN the workflow contains required fields (id, name, version, workflow) THEN the system SHALL accept the workflow definition
3. IF the workflow contains invalid JSON syntax THEN the system SHALL return a descriptive error message
4. WHEN the workflow references non-existent nodes THEN the system SHALL return a validation error before execution
```

## Special Instructions

1. **Be Comprehensive** - Extract ALL functionality mentioned in the spec
2. **Be Specific** - Avoid vague language; use concrete, measurable criteria
3. **Think Testing** - Write criteria that a QA engineer could turn into test cases
4. **Consider Edge Cases** - What could go wrong? What are the limits?
5. **Maintain Consistency** - Use consistent terminology throughout

## Final Checklist
- [ ] All major features from spec are covered
- [ ] Each requirement has a complete user story
- [ ] All acceptance criteria are testable
- [ ] Requirements are numbered sequentially
- [ ] No implementation details are specified
- [ ] Error cases are covered
- [ ] Performance requirements are included where relevant

Generate a complete requirements document based on the specification provided. Be thorough and systematic in your analysis.

---

### Input Context:

## Specification

# Task Management API Specification

## Overview

A RESTful API for managing tasks with user authentication, task CRUD operations, team collaboration features, and real-time updates. The system will support individual users and teams, with role-based access control and comprehensive task tracking capabilities.

## Core Features

### User Management
- User registration with email verification
- Secure authentication using JWT tokens
- Password reset functionality
- User profile management
- Role-based access control (Admin, Manager, Member)

### Task Management
- Create, read, update, and delete tasks
- Task properties: title, description, status, priority, due date, assignee
- Task statuses: Todo, In Progress, Review, Done
- Task priorities: Low, Medium, High, Critical
- File attachments support
- Task comments and activity history
- Task labels/tags for categorization

### Team Collaboration
- Create and manage teams
- Invite team members via email
- Assign tasks to team members
- Team-wide task visibility
- Permission levels within teams
- Team dashboards and analytics

### Real-time Features
- WebSocket connections for live updates
- Real-time task status changes
- Instant notifications for task assignments
- Live collaboration on task comments

### Search and Filtering
- Full-text search across tasks
- Filter by status, priority, assignee, due date
- Sort by multiple criteria
- Saved filter presets

## Technical Requirements

### Technology Stack
- Backend: Node.js with TypeScript
- Framework: Express.js or Fastify
- Database: PostgreSQL for relational data
- Cache: Redis for session management and real-time features
- Authentication: JWT with refresh tokens
- Real-time: Socket.io
- Testing: Jest for unit tests, Supertest for integration tests

### API Standards
- RESTful design principles
- JSON request/response format
- Consistent error handling
- API versioning (v1)
- OpenAPI/Swagger documentation
- Rate limiting for API protection

### Performance Requirements
- API response time < 200ms for standard operations
- Support for 1000 concurrent users
- Real-time updates delivered within 100ms
- Database queries optimized with proper indexing
- Pagination for large datasets (default 20 items)

### Security Requirements
- HTTPS only
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CORS configuration
- API key authentication for service-to-service communication
- Audit logging for sensitive operations

## Data Models

### User
- id (UUID)
- email (unique)
- password (hashed)
- firstName
- lastName
- role
- emailVerified
- createdAt
- updatedAt

### Team
- id (UUID)
- name
- description
- ownerId (User reference)
- createdAt
- updatedAt

### Task
- id (UUID)
- title
- description
- status
- priority
- dueDate
- assigneeId (User reference)
- teamId (Team reference)
- creatorId (User reference)
- labels (array)
- createdAt
- updatedAt
- completedAt

### TeamMember
- teamId (Team reference)
- userId (User reference)
- role (Admin, Manager, Member)
- joinedAt

### Comment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- content
- createdAt
- updatedAt

### Attachment
- id (UUID)
- taskId (Task reference)
- userId (User reference)
- fileName
- fileSize
- mimeType
- url
- uploadedAt

## API Endpoints Overview

### Authentication
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- POST /api/v1/auth/refresh
- POST /api/v1/auth/logout
- POST /api/v1/auth/forgot-password
- POST /api/v1/auth/reset-password
- GET /api/v1/auth/verify-email

### Users
- GET /api/v1/users/profile
- PUT /api/v1/users/profile
- DELETE /api/v1/users/profile

### Teams
- POST /api/v1/teams
- GET /api/v1/teams
- GET /api/v1/teams/:id
- PUT /api/v1/teams/:id
- DELETE /api/v1/teams/:id
- POST /api/v1/teams/:id/invite
- GET /api/v1/teams/:id/members
- DELETE /api/v1/teams/:id/members/:userId

### Tasks
- POST /api/v1/tasks
- GET /api/v1/tasks
- GET /api/v1/tasks/:id
- PUT /api/v1/tasks/:id
- DELETE /api/v1/tasks/:id
- POST /api/v1/tasks/:id/comments
- GET /api/v1/tasks/:id/comments
- POST /api/v1/tasks/:id/attachments
- GET /api/v1/tasks/:id/attachments

### Search
- GET /api/v1/search/tasks

### WebSocket Events
- task:created
- task:updated
- task:deleted
- task:assigned
- comment:added
- user:joined
- user:left

## Success Criteria

1. All CRUD operations for tasks functioning correctly
2. User authentication and authorization working securely
3. Team collaboration features operational
4. Real-time updates delivered reliably
5. API performance meeting specified benchmarks
6. Comprehensive test coverage (>80%)
7. API documentation complete and accurate
8. Security best practices implemented
9. Monitoring and logging in place
10. Deployment pipeline configured



### Instructions:
Ask your AI agent to generate the requirements document based on the prompt and context above.

---

Note: In a production environment, this script would integrate with an AI API (like Claude, OpenAI, etc.) to automatically generate this content.



### Instructions:
Ask your AI agent to generate the design document based on the prompt and context above.

---

Note: In a production environment, this script would integrate with an AI API (like Claude, OpenAI, etc.) to automatically generate this content.



### Instructions:
Ask your AI agent to generate the tasks document based on the prompt and context above.

---

Note: In a production environment, this script would integrate with an AI API (like Claude, OpenAI, etc.) to automatically generate this content.